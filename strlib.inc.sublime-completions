
{
	"scope": "source.pawn - variable.other.pawn",
	"completions":
	[
		{"trigger": "sprintf", "contents": "sprintf(${1:const fmat[]}, ${2:...})"},
		{"trigger": "strgetfirstc", "contents": "strgetfirstc(${1:const string[]})"},
		{"trigger": "strgetc", "contents": "strgetc(${1:const string[]}, ${2:index})"},
		{"trigger": "strsize", "contents": "strsize(${1:const string[]})"},
		{"trigger": "isempty", "contents": "isempty(${1:const string[]})"},
		{"trigger": "isequal", "contents": "isequal(${1:const str1[]}, ${2:const str2[]}, ${3:bool:ignorecase = false})"},
		{"trigger": "strexplode", "contents": "strexplode(${1:output[][]}, ${2:const input[]}, ${3:const delimiter[] = !\"}, ${4:limit = cellmax}, ${5:bool:trim = true}, ${6:bool:ignorecase = false}, ${7:size1 = sizeof(output})"},
		{"trigger": "strimplode", "contents": "strimplode(${1:const glue[]}, ${2:output[]}, ${3:maxlength = sizeof(output})"},
		{"trigger": "strreplace", "contents": "strreplace(${1:string[]}, ${2:const search[]}, ${3:const replacement[]}, ${4:bool:ignorecase = false}, ${5:pos = 0}, ${6:limit = -1}, ${7:maxlength = sizeof(string})"},
		{"trigger": "strtrim", "contents": "strtrim(${1:string[]}, ${2:const chars[] = !\"\"}, ${3:string_edges:edge = edge_both})"},
		{"trigger": "strpad", "contents": "strpad(${1:string[]}, ${2:length}, ${3:const substr[] = !\" \"}, ${4:string_edges:edge = edge_both}, ${5:bool:trim_first = true}, ${6:const trim_chars[] = !\"\"}, ${7:maxlength = sizeof(string})"},
		{"trigger": "strwrap", "contents": "strwrap(${1:const left[]}, ${2:string[]}, ${3:const right[]}, ${4:maxlength = sizeof(string})"},
		{"trigger": "strcount", "contents": "strcount(${1:const string[]}, ${2:const sub[]}, ${3:bool:ignorecase = false}, ${4:bool:count_overlapped = false})"},
		{"trigger": "strfromliteral", "contents": "strfromliteral(${1:output[]}, ${2:const input[]}, ${3:pos = 0}, ${4:maxlength = sizeof(output})"},
		{"trigger": "strtoliteral", "contents": "strtoliteral(${1:output[]}, ${2:const input[]}, ${3:maxlength = sizeof(output})"},
		{"trigger": "strfrombin", "contents": "strfrombin(${1:output[]}, ${2:const input[]}, ${3:inputlength = sizeof(input})"},
		{"trigger": "strtobin", "contents": "strtobin(${1:output[]}, ${2:const input[]}, ${3:maxlength = sizeof(output})"},
		{"trigger": "strcatmid", "contents": "strcatmid(${1:dest[]}, ${2:const source[]}, ${3:start = 0}, ${4:end = -1}, ${5:maxlength = sizeof(dest})"},
		{"trigger": "utf8encode", "contents": "utf8encode(${1:dest[]}, ${2:const source[]}, ${3:maxlength = sizeof(dest})"},
		{"trigger": "utf8decode", "contents": "utf8decode(${1:dest[]}, ${2:const source[]}, ${3:maxlength = sizeof(dest})"},
		{"trigger": "strurldecode", "contents": "strurldecode(${1:output[]}, ${2:const input[]}, ${3:maxlength = sizeof(output})"},
		{"trigger": "strurlencode", "contents": "strurlencode(${1:output[]}, ${2:const input[]}, ${3:maxlength = sizeof(output})"},
		{"trigger": "ret_strcatmid", "contents": "ret_strcatmid(${1:const string[]}, ${2:const source[]}, ${3:start = 0}, ${4:end = -1})"},
		{"trigger": "ret_strfrombin", "contents": "ret_strfrombin(${1:const input[]}, ${2:inputlength = sizeof(input})"},
		{"trigger": "ret_strimplode", "contents": "ret_strimplode(${1:const glue[]}, ${2:...})"},
		{"trigger": "ret_strreplace", "contents": "ret_strreplace(${1:const string[]}, ${2:const search[]}, ${3:const replacement[]}, ${4:bool:ignorecase = false}, ${5:pos = 0}, ${6:limit = -1})"},
		{"trigger": "ret_strfromliteral", "contents": "ret_strfromliteral(${1:const input[]}, ${2:pos = 0})"},
		{"trigger": "ret_strtoliteral", "contents": "ret_strtoliteral(${1:const input[]}, ${2:bool:paranoid = true})"},
		{"trigger": "ret_strtrim", "contents": "ret_strtrim(${1:const string[]}, ${2:const chars[] = !\"\"}, ${3:string_edges:edge = edge_both})"},
		{"trigger": "ret_strpad", "contents": "ret_strpad(${1:const string[]}, ${2:length}, ${3:const substr[] = !\" \"}, ${4:string_edges:edge = edge_both}, ${5:bool:trim_first = true}, ${6:const trim_chars[] = !\"\"})"},
		{"trigger": "ret_strwrap", "contents": "ret_strwrap(${1:const left[]}, ${2:const string[]}, ${3:const right[]})"},
		{"trigger": "ret_strurldecode", "contents": "ret_strurldecode(${1:const input[]})"},
		{"trigger": "ret_strurlencode", "contents": "ret_strurlencode(${1:const input[]}, ${2:bool:pack = false})"},
		{"trigger": "ret_utf8encode", "contents": "ret_utf8encode(${1:const input[]})"},
		{"trigger": "ret_utf8decode", "contents": "ret_utf8decode(${1:const input[]})"},
		{"trigger": "ret_strunpack", "contents": "ret_strunpack(${1:const source[]})"},
		{"trigger": "ret_strcat", "contents": "ret_strcat(${1:const string1[]}, ${2:const string2[]})"},
		{"trigger": "ret_strmid", "contents": "ret_strmid(${1:const source[]}, ${2:start}, ${3:end})"},
		{"trigger": "ret_strins", "contents": "ret_strins(${1:const string[]}, ${2:const substr[]}, ${3:pos}, ${4:maxlength = sizeof(string})"},
		{"trigger": "ret_strdel", "contents": "ret_strdel(${1:const string[]}, ${2:start}, ${3:end})"},
		{"trigger": "ret_valstr", "contents": "ret_valstr(${1:value}, ${2:bool:pack = false})"},
		{"trigger": "ret_GetPlayerName", "contents": "ret_GetPlayerName(${1:playerid}, ${2:bool:pack = false})"}
	]
}
